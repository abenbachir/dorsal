From f3b3ff3768deef943b59df04e446621f9ef13283 Mon Sep 17 00:00:00 2001
From: Abderrahmane Benbachir <abderrahmane.benbachir@polymtl.ca>
Date: Tue, 23 May 2017 18:25:39 -0400
Subject: [PATCH] ftrace: add hypergraph tracer

Send to host, function entry & exit and sched_switch events through hypercalls.

Signed-off-by: Abderrahmane Benbachir <abderrahmane.benbachir@polymtl.ca>
---
 kernel/trace/Makefile           |   1 +
 kernel/trace/trace.c            |  10 ++
 kernel/trace/trace.h            |   1 +
 kernel/trace/trace_hypergraph.c | 310 ++++++++++++++++++++++++++++++++++++++++
 4 files changed, 322 insertions(+)
 create mode 100644 kernel/trace/trace_hypergraph.c

diff --git a/kernel/trace/Makefile b/kernel/trace/Makefile
index e57980845549..688c553ec872 100644
--- a/kernel/trace/Makefile
+++ b/kernel/trace/Makefile
@@ -42,6 +42,7 @@ obj-$(CONFIG_NOP_TRACER) += trace_nop.o
 obj-$(CONFIG_STACK_TRACER) += trace_stack.o
 obj-$(CONFIG_MMIOTRACE) += trace_mmiotrace.o
 obj-$(CONFIG_FUNCTION_GRAPH_TRACER) += trace_functions_graph.o
+obj-$(CONFIG_FUNCTION_GRAPH_TRACER) += trace_hypergraph.o
 obj-$(CONFIG_TRACE_BRANCH_PROFILING) += trace_branch.o
 obj-$(CONFIG_BLK_DEV_IO_TRACE) += blktrace.o
 ifeq ($(CONFIG_BLOCK),y)
diff --git a/kernel/trace/trace.c b/kernel/trace/trace.c
index d7449783987a..3b7a515298c2 100644
--- a/kernel/trace/trace.c
+++ b/kernel/trace/trace.c
@@ -1711,6 +1711,16 @@ int is_tracing_stopped(void)
 	return global_trace.stop_count;
 }
 
+int is_default_bootup_tracer(const char *name)
+{
+	if (!default_bootup_tracer)
+		return 0;
+
+	if (strncmp(default_bootup_tracer, name, MAX_TRACER_SIZE) != 0)
+		return 0;
+	return 1;
+}
+
 /**
  * tracing_start - quick start of the tracer
  *
diff --git a/kernel/trace/trace.h b/kernel/trace/trace.h
index 1ea51ab53edf..212c5bc4b992 100644
--- a/kernel/trace/trace.h
+++ b/kernel/trace/trace.h
@@ -634,6 +634,7 @@ void tracing_start_cmdline_record(void);
 void tracing_stop_cmdline_record(void);
 int register_tracer(struct tracer *type);
 int is_tracing_stopped(void);
+int is_default_bootup_tracer(const char *name);
 
 loff_t tracing_lseek(struct file *file, loff_t offset, int whence);
 
diff --git a/kernel/trace/trace_hypergraph.c b/kernel/trace/trace_hypergraph.c
new file mode 100644
index 000000000000..6ab8e3d10249
--- /dev/null
+++ b/kernel/trace/trace_hypergraph.c
@@ -0,0 +1,310 @@
+/*
+ *
+ * Hypergraph : Function graph tracer specific for virtual machine.
+ * Instead of using the buffer we send function entry & exit and
+ * sched_switch events through hypercalls.
+ *
+ * Copyright (c) 2018-2017 Abderrahmane Benbachir <abderrahmane.benbachir@polymtl.ca>
+ * Inspired from function_graph and function tracers which is Copyright (c)
+ * S. Rostedt <srostedt@redhat.com> and F. Weisbecker <fweisbec@gmail.com>
+ */
+#include <linux/uaccess.h>
+#include <linux/module.h>
+#include <linux/ftrace.h>
+#include <linux/interrupt.h>
+#include <linux/slab.h>
+#include <linux/fs.h>
+#include <trace/events/sched.h>
+#include <asm/setup.h>
+#include <linux/hypervisor.h>
+#include "trace.h"
+
+#define FUNCTION_ENTRY 0
+#define FUNCTION_EXIT 1
+#define FUNCTION_EXIT_ONLY 2
+#define HYPERGRAPH_HYPERCALL_NR 1000
+#define HYPERGRAPH_SCHED_SWITCH_HYPERCALL_NR 1001
+#define HYPERGRAPH_START_HYPERCALL_NR 1002
+#define HYPERGRAPH_STOP_HYPERCALL_NR 1003
+
+// TODO: support x86_32 too
+#define do_hypercall(nr, p1, p2, p3, p4) \
+	__asm__ __volatile__(".byte 0x0F,0x01,0xC1\n"::"a"(nr), \
+	"b"(p1), "c"(p2), "d"(p3), "S"(p4))
+
+#define do_hypercall_for_start() do_hypercall(HYPERGRAPH_START_HYPERCALL_NR, max_depth, exit_only_mode, stop_tracing_at, 0)
+
+#define do_hypercall_for_stop() do_hypercall(HYPERGRAPH_STOP_HYPERCALL_NR, max_depth, exit_only_mode, stop_tracing_at, 0)
+
+static int bootup_tracing_enabled;
+
+static int tracing_enabled;
+
+static unsigned int max_depth;
+/*
+ * When exit_only_mode is set, only exit events are sent
+ * the callgraph can still be built using pre-order traversal tree
+ */
+static unsigned int exit_only_mode;
+/* When set, irq functions will be traced */
+static int hypergraph_irqs_enabled;
+
+static unsigned long stop_tracing_at;
+
+static struct trace_array *hypergraph_array;
+
+static void hypergraph_trace_stop(struct trace_array *tr);
+
+static inline int ftrace_hypergraph_stop_tracing_at(unsigned long ip)
+{
+	return unlikely(stop_tracing_at == ip);
+}
+
+static inline int ftrace_hypergraph_ignore_irqs(void)
+{
+	if (hypergraph_irqs_enabled /*|| trace_recursion_test(TRACE_IRQ_BIT)*/)
+		return 0;
+
+	return irq_count();
+}
+
+static void probe_sched_switch(void *ignore, bool preempt,
+		struct task_struct *prev, struct task_struct *next)
+{
+	/*
+	 * Do hypercall to send sched_switch event to host
+	 */
+	if (tracing_enabled)
+		do_hypercall(HYPERGRAPH_SCHED_SWITCH_HYPERCALL_NR,
+			prev->pid,
+			prev->tgid,
+			next->pid,
+			next->tgid);
+}
+
+static int trace_hypergraph_entry(struct ftrace_graph_ent *trace)
+{
+	struct trace_array *tr = hypergraph_array;
+
+	if (!tracing_enabled || !ftrace_trace_task(tr))
+		return 0;
+
+	/* Disable tracing when reaching a specific function */
+	if (ftrace_hypergraph_stop_tracing_at(trace->func))
+		hypergraph_trace_stop(NULL);
+
+	/* trace it when it is-nested-in or is a function enabled. */
+	if (!(trace->depth || ftrace_graph_addr(trace->func)) ||
+		(trace->depth < 0) ||
+		(max_depth && trace->depth >= max_depth))
+		return 0;
+
+	if (ftrace_hypergraph_ignore_irqs())
+		return 0;
+
+	/*
+	 * Do not trace a function if it's filtered by set_graph_notrace.
+	 * Make the index of ret stack negative to indicate that it should
+	 * ignore further functions.  But it needs its own ret stack entry
+	 * to recover the original index in order to continue tracing after
+	 * returning from the function.
+	 */
+	if (ftrace_graph_notrace_addr(trace->func))
+		return 1;
+
+	/*
+	 * Stop here if exit_only_mode is set. We only send function return
+	 * events to host.
+	 */
+	if (exit_only_mode)
+		return 1;
+
+	/*
+	 * Do hypercall to send function entry event to host
+	 */
+	do_hypercall(HYPERGRAPH_HYPERCALL_NR,
+		trace->func,
+		FUNCTION_ENTRY,
+		0,
+		trace->depth);
+
+	return 1;
+}
+
+static void trace_hypergraph_return(struct ftrace_graph_ret *trace)
+{
+	/*
+	 * Do hypercall to send function exit event to host
+	 */
+	do_hypercall(HYPERGRAPH_HYPERCALL_NR,
+		trace->func,
+		(exit_only_mode ? FUNCTION_EXIT_ONLY : FUNCTION_EXIT),
+		(trace->rettime - trace->calltime),
+		trace->depth);
+}
+
+static void hypergraph_trace_start(struct trace_array *tr)
+{
+	tracing_enabled = 1;
+	do_hypercall_for_start();
+}
+
+static void hypergraph_trace_stop(struct trace_array *tr)
+{
+	if (tracing_enabled)
+		do_hypercall_for_stop();
+	tracing_enabled = 0;
+}
+
+static int hypergraph_trace_init(struct trace_array *tr)
+{
+	int ret;
+
+	ret = register_trace_sched_switch(probe_sched_switch, NULL);
+	if (ret) {
+		pr_info("sched trace: Couldn't activate tracepoint"
+		    " probe to kernel_sched_switch\n");
+	}
+
+	hypergraph_array = tr;
+
+	ret = register_ftrace_graph(&trace_hypergraph_return,
+				    &trace_hypergraph_entry);
+
+	if (ret)
+		return ret;
+
+	// Enable tracing during bootup
+	if (bootup_tracing_enabled) {
+		bootup_tracing_enabled = 0;
+		hypergraph_trace_start(tr);
+	}
+
+	return 0;
+}
+
+static void hypergraph_trace_reset(struct trace_array *tr)
+{
+	tracing_enabled = 0;
+	unregister_ftrace_graph();
+	unregister_trace_sched_switch(probe_sched_switch, NULL);
+}
+
+static struct tracer hypergraph_trace __tracer_data = {
+	.name		= "hypergraph",
+	.init		= hypergraph_trace_init,
+	.reset		= hypergraph_trace_reset,
+	.start		= hypergraph_trace_start,
+	.stop		= hypergraph_trace_stop
+};
+
+static ssize_t
+hypergraph_depth_write(struct file *filp, const char __user *ubuf,
+			size_t cnt, loff_t *ppos)
+{
+	unsigned long val;
+	int ret;
+
+	ret = kstrtoul_from_user(ubuf, cnt, 10, &val);
+	if (ret)
+		return ret;
+
+	max_depth = val;
+	*ppos += cnt;
+	return cnt;
+}
+
+static ssize_t
+hypergraph_depth_read(struct file *filp, char __user *ubuf,
+			size_t cnt, loff_t *ppos)
+{
+	char buf[15]; /* More than enough to hold UINT_MAX + "\n"*/
+	int n;
+
+	n = sprintf(buf, "%d\n", max_depth);
+	return simple_read_from_buffer(ubuf, cnt, ppos, buf, n);
+}
+
+static const struct file_operations hypergraph_depth_fops = {
+	.open		= tracing_open_generic,
+	.write		= hypergraph_depth_write,
+	.read		= hypergraph_depth_read,
+	.llseek		= generic_file_llseek,
+};
+
+static __init int init_hypergraph_tracefs(void)
+{
+	struct dentry *d_tracer;
+
+	d_tracer = tracing_init_dentry();
+	if (IS_ERR(d_tracer))
+		return 0;
+
+	trace_create_file("max_hypergraph_depth", 0644, d_tracer,
+		NULL, &hypergraph_depth_fops);
+
+	return 0;
+}
+fs_initcall(init_hypergraph_tracefs);
+
+/*
+ * command line interface to allow users to set config on boot up.
+ */
+static __init int set_max_hypergraph_depth(char *str)
+{
+	long val;
+
+	if (kstrtol(str, 10, &val) == 0)
+		max_depth = val;
+
+	return 1;
+}
+__setup("ftrace_hypergraph_max_depth=", set_max_hypergraph_depth);
+
+static __init int hypergraph_irqs_enable(char *str)
+{
+	long val;
+
+	if (kstrtol(str, 10, &val) == 0)
+		hypergraph_irqs_enabled = val > 0;
+
+	return 1;
+}
+__setup("ftrace_hypergraph_irqs_enable=", hypergraph_irqs_enable);
+
+static __init int hypergraph_exit_only_mode(char *str)
+{
+	long val;
+
+	if (kstrtol(str, 10, &val) == 0)
+		exit_only_mode = val > 0;
+
+	return 1;
+}
+__setup("ftrace_hypergraph_exit_only=", hypergraph_exit_only_mode);
+
+static __init int set_hypergraph_stop_at(char *str)
+{
+	stop_tracing_at = kallsyms_lookup_name(str);
+	return 1;
+}
+__setup("hypergraph_stop_at=", set_hypergraph_stop_at);
+
+
+static __init int init_hypergraph_trace(void)
+{
+	int ret;
+
+	if (!x86_hyper) {
+		pr_info("ftrace hypergraph tracer is not registered:"
+			" no hypervisor was detected\n");
+		return 0;
+	}
+
+	bootup_tracing_enabled = is_default_bootup_tracer(hypergraph_trace.name);
+
+	ret = register_tracer(&hypergraph_trace);
+	return ret;
+}
+
+early_initcall(init_hypergraph_trace);
-- 
2.11.0

