

PATCH v2:

1) The save and restore above looks to be a cut and paste copy of the
ftrace_caller code in the same file. Why not have those uses this too,
instead of having duplicate code?


2) Never put default y unless you have a very good reason to do so. The
DYNAMIC_FTRACE is default y because it is only enabled when
FUNCTION_TRACER is enabled, and DYNAMIC_FTRACE is better than static
ftrace.

This is to be default n (which is the default, so just remove the
default y).

3) OK, the help text needs a rewrite ;-)
        help
          Normally, function tracing can only start after memory has
          been initialized early in boot. If "ftrace=function" is added
          to the command line, then function tracing will start after
          memory setup.

          In order to trace functions before that, this option will
          have function tracing tracing before memory setup is
          complete, by placing the trace in a temporary buffer, which
          will be copied to the trace buffer after memory setup. The
          size of this temporary buffer is defined by
          VERY_EARLY_BUF_SHIFT.


4) config VERY_EARLY_BUF_SHIFT
Probably should call this "VERY_EARLY_FTRACE_BUF_SHIFT" Just to be more
specific.
Should probably have the range start at 8.

5) Probably want to include the kernel parameter used: "ftrace_filter" "ftrace_notrace"

6) remove #include <linux/trace.h>

7) #define ftrace_vearly_disable() (ftrace_vearly_trace_function = ftrace_stub)
Make this a static inline function.

8) make filters depends on FTRACE_MCOUNT_RECORD instead of CONFIG_DYNAMIC_FTRACE

9) use ring_buffer_set_clock
-------------------------------------------------------------------------------------
PATCH v1:
1) Use ARRAY_SIZE(ftrace_vearly_params) instead of sizeof
Also, have the declarations in upside-down x-mas tree order. (Declare,
size, p then i) where smallest line length is last.

2) static char tmp_cmdline[COMMAND_LINE_SIZE] __initdata;
If you define the above as __initdata, just keep it out of the function
itself.

3) Pull __start_mcount_loc[]; out of ftrace_init, and just 
have them declared once (outside of any function).

5) Never include arch specific code in generic code.

6) native_calibrate_cpu() only exists in x86. You just broke the build for
all other architectures.

4)The above two functions can be consolidated into one, and just pass the
ftrace_vearly_(notrace/filter)_buf and
ftrace_vearly_(notrace/filter)_list, vearly_(notrace/filter)_count to
it as parameters. Don't duplicate the logic.

7) CONFIG_VERY_EARLY_FUNCTION_TRACER
depends CONFIG_FUNCTION_TRACER
depends CONFIG_HAVE_VERY_EARLY_FTRACE


2) make VEARLY_BUF_SIZE configurable
Perhaps defined as a config, or even
modified via kernel command line. The latter would require a way to
allocate it. A compile time config option should be added at least.

9) make VEARLY_FILTER_SIZE configurable, and perhaps even disabled if chosen to be so.


--------------------------------- DONE --------------------------
10) Don't create new trace_function_timestamp  Use trace_function() instead. Perhaps
enable ftrace_exports to add a hook to update the timestamp.

Then you need to add a handler into the ring buffer code to update the
timestamp for you. More below.

add a hook into ftrace_exports() and then add a handler into the ring
buffer that allows you to update the timestamp.



